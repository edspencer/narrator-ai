"use strict";(self.webpackChunkdocs_2=self.webpackChunkdocs_2||[]).push([[156],{4831:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=n(4848),r=n(8453);const s={sidebar_position:2,title:"Generating Content"},a="Generating Content",i={id:"generation",title:"Generating Content",description:"All of the configurations for Narrator are optional, but if you want to generate and save content you can pass in outputDir and (optionally) outputFilename to have Narrator automatically save its generations for you. For example, if we want to save our generated content as .md files in the ./editorial directory, we can configure it like this:",source:"@site/docs/generation.md",sourceDirName:".",slug:"/generation",permalink:"/generation",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Generating Content"},sidebar:"docs",previous:{title:"NarratorAI Introduction",permalink:"/"},next:{title:"Rendering Content",permalink:"/rendering"}},c={},l=[{value:"Prompting",id:"prompting",level:2},{value:"Factory pattern",id:"factory-pattern",level:3},{value:"Batch Generating",id:"batch-generating",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"generating-content",children:"Generating Content"})}),"\n",(0,o.jsxs)(t.p,{children:["All of the configurations for Narrator are optional, but if you want to generate and save content you can pass in ",(0,o.jsx)(t.code,{children:"outputDir"})," and (optionally) ",(0,o.jsx)(t.code,{children:"outputFilename"})," to have Narrator automatically save its generations for you. For example, if we want to save our generated content as ",(0,o.jsx)(t.code,{children:".md"})," files in the ",(0,o.jsx)(t.code,{children:"./editorial"})," directory, we can configure it like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:'export const narrator = new Narrator({\n  outputFilename: (docId) => `${docId}.md`,\n  outputDir: path.join(process.cwd(), "editorial"),\n});\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Now we can generate some content, which in this case will be saved to ",(0,o.jsx)(t.code,{children:"./editorial/tag/ai.md"})," (directories will be created for you):"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:'const content = await narrator.generate(\n  {\n    docId: "tag/ai",\n    suffix: "Please reply with only the markdown you generate", //suffix is optional\n    prompt: `\nThese are summaries of my most recent articles about AI. Your task is to generate a 2-3 sentence\nintroduction that tells readers at-a-glance what I\'ve been writing about. Please generate markdown,\nand include links to the articles. Do not use triple backticks or section headings in your response.\n\n<<Articles go here>>\n`,\n  },\n  { save: true }\n);\n'})}),"\n",(0,o.jsxs)(t.p,{children:["This will generate content for you and save it according to the configuration you provided. You can set ",(0,o.jsx)(t.code,{children:"docId"})," to whatever you want - in this case we're generating intro text for a blog that contains ",(0,o.jsx)(t.a,{href:"https://edspencer.net/blog/tag/ai",children:"articles about AI"}),". If you don't specify a ",(0,o.jsx)(t.code,{children:"model"}),' it will default to using OpenAI\'s "gpt-4o", but you can pass in any model provided by the ',(0,o.jsx)(t.a,{href:"https://sdk.vercel.ai/docs/introduction",children:"Vercel AI SDK"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"prompting",children:"Prompting"}),"\n",(0,o.jsxs)(t.p,{children:["In the example above I left an ",(0,o.jsx)(t.code,{children:"<<Articles go here>>"})," string inside the ",(0,o.jsx)(t.code,{children:"prompt"})," that I passed to ",(0,o.jsx)(t.code,{children:"generate()"}),", but that's not much use - we need to provide the articles themselves. My prompt also referred to summaries of the articles - you could pass the whole article in but it's generally a better idea to summarize them first or the LLM can lose track of what its supposed to be doing."]}),"\n",(0,o.jsxs)(t.p,{children:["Generating the prompt strings is really up to you, but a good pattern is to use a Factory to create the ",(0,o.jsx)(t.code,{children:"prompt"})," for a given docId. This allows you to encapsulate the logic for fetching those articles (or whatever else you need to fetch) in a centralized place, and as an added benefit makes it easy to regenerate content for a given ",(0,o.jsx)(t.code,{children:"docId"})," - which is exactly what ",(0,o.jsx)(t.a,{href:"https://www.npmjs.com/package/@narrator-ai/react",children:"@narrator-ai/react"}),' does when you click the "Regenerate section" button.']}),"\n",(0,o.jsx)(t.h3,{id:"factory-pattern",children:"Factory pattern"}),"\n",(0,o.jsx)(t.p,{children:"Here's a simplified version of the Factory I use to generate content for my blog. I generate 3 types of content:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Tag intro sections - docIds like ",(0,o.jsx)(t.code,{children:"tag/ai"})," or ",(0,o.jsx)(t.code,{children:"tag/rsc"})]}),"\n",(0,o.jsxs)(t.li,{children:["Post outro sections - docIds like ",(0,o.jsx)(t.code,{children:"post/whatever-the-post-url-slug-is"})]}),"\n",(0,o.jsxs)(t.li,{children:["Blog intro section - like a tag intro section but it's for all recent posts (docId is ",(0,o.jsx)(t.code,{children:"recent-posts"}),")"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"I'll skip that last category for simplicity and pretend we only generate tag intros and post outros:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:'class TaskFactory {\n  //returns a GenerationTask for a given docId\n  jobForId(docId: string): GenerationTask {\n    const [exampleKey, slug] = docId.split("/");\n    const { publishedPosts } = this.posts;\n\n    if (exampleKey === "post") {\n      return this.postJob(publishedPosts.find((post) => post.slug === slug));\n    } else if (exampleKey === "tag") {\n      return this.tagJob({ tag: slug });\n    }\n  }\n\n  //returns a GenerationTask for a post outro\n  postJob(post): GenerationTask {\n    //summaries of related articles\n    const relatedArticles = post.related\n      ?.map((slug) => this.posts.publishedPosts.find((p) => p.slug === slug))\n      .map((post) => ({ post, summary: this.readNext.getSummaryById(post.slug) }));\n\n    return {\n      docId: `post/${post.slug}`,\n      prompt: postReadNextPrompt(post, this.posts.getContent(post), relatedArticles),\n      suffix: "Please reply with a 2 sentence suggestion for what the reader should read next.",\n    };\n  }\n\n  //returns a GenerationTask for a tag intro\n  tagJob({ tag }): GenerationTask {\n    //the 10 most recent posts for a given tag\n    const recentPosts = this.posts.publishedPosts\n      .filter((post) => post.tags.includes(tag))\n      .slice(0, 10)\n      .map((post) => ({ post, summary: this.readNext.getSummaryById(post.slug) }));\n\n    return {\n      docId: `tag/${tag}`,\n      prompt: tagIntroPrompt(tag, recentPosts),\n    };\n  }\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["A ",(0,o.jsx)(t.code,{children:"GenerationTask"})," is just a type with a ",(0,o.jsx)(t.code,{children:"docId"}),", ",(0,o.jsx)(t.code,{children:"prompt"})," and optional ",(0,o.jsx)(t.code,{children:"suffix"})," to help keep the LLM on track. I have a little class called ",(0,o.jsx)(t.code,{children:"Posts"})," that exposes ",(0,o.jsx)(t.code,{children:"publishedPosts"})," and a way to ",(0,o.jsx)(t.code,{children:"getContent"})," for a given post - pretty basic stuff. Both types of task are using ",(0,o.jsx)(t.a,{href:"https://github.com/edspencer/read-next",children:"ReadNext"})," to generate article summaries (as well as populating the list of related articles for the postJob), but you can do that however you like."]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"tagIntroPrompt"})," and ",(0,o.jsx)(t.code,{children:"postReadNextPrompt"})," functions just return strings that get passed in as the ",(0,o.jsx)(t.code,{children:"prompt"}),". Here's what my ",(0,o.jsx)(t.code,{children:"tagIntroPrompt"})," function looks like:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:'//it\'s just a string. A long string, but a string.\nfunction tagIntroPrompt(tag: string, recentPosts: RecentPost[] = []) {\n  return `\n    These are summaries of the ${recentPosts.length} most recent blog posts on my technical blog for the tag "${tag}".\n    The summaries have been specifically prepared for you so that you have the context you need to \n    a very brief 2 paragraph overview of what I\'ve been writing about recently regarding this tag. I want you \n    to write this editorial in my own tone of voice, as if I were writing it myself. It should be around 100 words.\n    \n    Your response will be rendered in a markdown file and published on my blog. It should contain \n    several links to various posts, giving extra credence to topics that have been covered more than\n    once, or covering open source projects that I\'ve been working on. You will be told the article\n    relative url for each post, so you can link to them in your editorial. Please link to as many\n    posts as you can.\n    All of the links inside the text that you generate should be relative links, precisely matching\n    the relativeLink you were given for each post, or absolute links with edspencer.net as the domain.\n    \n    Do not include any headings as there is already a heading for this section in the page layout.\n  \n    If the most recent articles are more than 5 years old, the first part of your answer should be to point out\n    to the reader that nothing has been posted for this tag in a while.\n  \n    Keep it humble and not too high-faluting. I\'m a technical writer, not a poet. Avoid starting with the phrase\n    "I\'ve been diving in" or similar.\n    \n    Here are the summaries of the recent blog posts:\n    \n    ${recentPosts.map(({ post, summary }) => articleRenderer(post, summary)).join("\\n\\n")}  \n\n    You must not include \\`\\`\\`markdown or \\`\\`\\`html code blocks in your response.\n    You must not include any headings in your response.\n`;\n}\n\n//LLM-friendly string for a given post summary\nconst articleRenderer = (post, summary) => `\nARTICLE METADATA:\nArticle Title: ${post.title}\nArticle relative url: ${post.relativeLink}\nTags: ${post.tags.join(", ")}\nPublished: ${timeAgo.format(new Date(post.date))}\nARTICLE SUMMARY: ${summary}\n`;\n'})}),"\n",(0,o.jsx)(t.p,{children:"Now we can generate/regenerate content for a section just based on a docId string:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:'await narrator.generate(factory.taskForId("tag/ai"));\n'})}),"\n",(0,o.jsx)(t.h3,{id:"batch-generating",children:"Batch Generating"}),"\n",(0,o.jsx)(t.p,{children:"It's probably pretty obvious now how to generate more than one piece of content. Here's a simple script I use to do it for my blog:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:'//to expose the OPENAI_API_KEY\nimport * as dotenv from "dotenv";\ndotenv.config();\n\nimport Posts from "@/lib/blog/Posts";\nimport { TaskFactory, narrator } from "@/lib/blog/TaskFactory";\n\nasync function main() {\n  const taskFactory = new TaskFactory();\n  const posts = new Posts();\n\n  //generate post "read next" outros\n  for (const post of posts.publishedPosts) {\n    await narrator.generate(taskFactory.jobForId(`post/${post.slug}`)!, { save: true });\n  }\n\n  //generate the intro per tag (but only for tags with 3 or more posts)\n  const tags = posts.getTagsWithCounts().filter(({ count }) => count > 3);\n\n  for (const tag of tags) {\n    await narrator.generate(taskFactory.jobForId(`tag/${tag.tag}`)!, { save: true });\n  }\n\n  //generate the overall /blog intro\n  await narrator.generate(taskFactory.jobForId("recent-posts")!);\n}\n\nmain()\n  .catch(console.error)\n  .then(() => process.exit(0));\n'})}),"\n",(0,o.jsxs)(t.p,{children:["In my ",(0,o.jsx)(t.code,{children:"package.json"})," I added a couple of ",(0,o.jsx)(t.code,{children:"scripts"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-json",children:'  "scripts": {\n    "narrator:train": "npx tsx script/train-narrator.ts",\n    "narrator:generate": "npx tsx script/generate-narration.ts"\n  },\n'})}),"\n",(0,o.jsx)(t.p,{children:"So now I can just run this to generate all of the meta-content for my blog:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sh",children:"npm run narrator:generate\n"})}),"\n",(0,o.jsxs)(t.p,{children:["My actual script uses ",(0,o.jsx)(t.a,{href:"https://www.npmjs.com/package/commander",children:"commander"})," so that I can have it just do the posts, the tags, the overview, or some combination based on flags I pass in, but you get the idea."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var o=n(6540);const r={},s=o.createContext(r);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);